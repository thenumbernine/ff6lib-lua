#!/usr/bin/env rua
require 'vec-ffi'
local gl = require 'gl.setup'(cmdline.gl)
local Image = require 'image'
local GLTex2D = require 'gl.tex2d'
local GLGeometry = require 'gl.geometry'
local GLSceneObject = require 'gl.sceneobject'
local ig = require 'imgui'
local makePalette = require 'ff6.graphics'.makePalette

local infn = cmdline[2]
assert(infn, "missing filename")
local data = assert(path(infn):read())
if #data == 0x300200 then
	data = data:sub(0x201)
end

local rom = ffi.cast('uint8_t*', data)
local game = require 'ff6'(rom)
local countof = game.countof

local App = require 'imgui.appwithorbit'()
App.title = 'FF6 Data Visualizer'

App.initGL = |:, ...|do
	App.super.initGL(self, ...)

	self.view.ortho = true
	self.view.orthoSize = 1

	self.drawObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
uniform mat4 mvProjMat;
void main() {
	tcv = vec2(vertex.x, 1. - vertex.y);
	gl_Position = mvProjMat * vec4(vertex * 2. - 1., 0., 1.);
}
]],
			fragmentCode = [[
uniform usampler2D tex;
uniform sampler2D palTex;
in vec2 tcv;
out vec4 fragColor;
void main() {
	int index = int(texture(tex, tcv, 0).r);
	fragColor = texture(palTex, vec2(
		(float(index) + .5) / 128.,
		0.
	), 0);
}
]],
			uniforms = {
				tex = 0,
				palTex = 1,
			},
		},
		vertexes = {
			data = {
				0, 0,
				1, 0,
				0, 1,
				1, 1,
			},
			dim = 2,
		},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		}
	}


	self.mapIndex = 0
	self:updateMapIndex()
end

App.updateMapIndex = |:|do
	local mapIndex = self.mapIndex
print('updateMapIndex', mapIndex)

	if self.palTex then
		self.palTex:delete()
		self.palTex = nil
	end
	if self.layerTexs then
		for _,tex in ipairs(self.layerTexs) do
			tex:delete()
		end
		self.layerTexs = nil
	end

	collectgarbage()

	local mapInfo = game.getMap(mapIndex)
	local palette = mapInfo.palette

	if not palette then return end

	local palData = ffi.new'uint8_t[128*4]'
	ffi.fill(palData, ffi.sizeof(palData))
	for i=0,127 do
		for j=0,3 do
			palData[j|(i<<2)] = assert(palette[i+1][j+1])
		end
	end
	self.palTex = GLTex2D{
		width = 16*8,
		height = 1,
		internalFormat = gl.GL_RGBA,
		format = gl.GL_RGBA,
		type = gl.GL_UNSIGNED_BYTE,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		data = palData,
	}:unbind()
assert.eq(self.palTex.data, palData)

	self.layerTexs = mapInfo
		:getLayerImages()
		:mapi(|img|
			GLTex2D{
				width = img.width,
				height = img.height,
				internalFormat = gl.GL_R8UI,
				format = gl.GL_RED_INTEGER,
				type = gl.GL_UNSIGNED_BYTE,
				minFilter = gl.GL_NEAREST,
				magFilter = gl.GL_NEAREST,
				data = img.buffer,
			}:unbind()
		)
end

App.update = |:|do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT)

	gl.glEnable(gl.GL_BLEND)
	gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE)

	self.drawObj.uniforms.mvProjMat = self.view.mvProjMat.ptr

	if self.layerTexs then
		self.drawObj.texs[2] = self.palTex
		for i,tex in ipairs(self.layerTexs) do
			local k = 'drawLayer'..i
			if self[k] == nil or self[k] == true then
				self.drawObj.texs[1] = tex
				self.drawObj:draw()
			end
		end
	end

	-- draw gui
	App.super.update(self)
end

App.updateGUI = |:|do
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'map:' then
			if ig.luatableInputInt('mapIndex', self, 'mapIndex') then
				self.mapIndex = self.mapIndex:floor():clamp(0, countof(game.maps)-1)
				self:updateMapIndex()
			end

			if self.layerTexs then
				for i=1,#self.layerTexs do
					if i > 1 then
						ig.igSameLine()
					end
					local k = 'drawLayer'..i
					if self[k] == nil then self[k] = true end
					ig.luatableTooltipCheckbox('tex '..i, self, k)
				end
			end

			ig.igEndMenu()
		end

		local label = 'viewing map #'..self.mapIndex
		if ig.igBeginMenu(label) then
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
end

return App():run()
