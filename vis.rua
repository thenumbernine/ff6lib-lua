#!/usr/bin/env rua
require 'vec-ffi'
local gl = require 'gl.setup'(cmdline.gl)
local Image = require 'image'
local GLTex2D = require 'gl.tex2d'
local GLGeometry = require 'gl.geometry'
local GLSceneObject = require 'gl.sceneobject'
local ig = require 'imgui'
local makePalette = require 'ff6.graphics'.makePalette

local infn = cmdline[2]
assert(infn, "missing filename")
local data = assert(path(infn):read())
if #data == 0x300200 then
	data = data:sub(0x201)
end

local rom = ffi.cast('uint8_t*', data)
local game = require 'ff6'(rom)

-- don't lose these.  they will GC otherwise.
_G.data = data
_G.rom = rom
_G.game = game

local countof = game.countof



local App = require 'imgui.appwithorbit'()
App.title = 'FF6 Data Visualizer'

App.initGL = |:, ...|do
	App.super.initGL(self, ...)

	self.view.ortho = true
	self.view.orthoSize = 1

	self.drawObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
uniform mat4 mvProjMat;
void main() {
	tcv = vec2(vertex.x, 1. - vertex.y);
	gl_Position = mvProjMat * vec4(vertex * 2. - 1., 0., 1.);
}
]],
			fragmentCode = [[
uniform usampler2D tex;
uniform sampler2D palTex;
in vec2 tcv;
out vec4 fragColor;
void main() {
	int index = int(texture(tex, tcv, 0).r);
	fragColor = texture(palTex, vec2(
		(float(index) + .5) / 128.,
		0.
	), 0);
}
]],
			uniforms = {
				tex = 0,
				palTex = 1,
			},
		},
		vertexes = {
			data = {
				0, 0,
				1, 0,
				0, 1,
				1, 1,
			},
			dim = 2,
		},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		}
	}
	
	self.mapSize = vec2d()

	self.mapIndex = 0
	self:updateMapIndex()
end

App.updateMapIndex = |:|do
	local mapIndex = self.mapIndex
print('updateMapIndex', mapIndex)

	if self.palTex then
		self.palTex:delete()
		self.palTex = nil
	end
	if self.layerTexs then
		for _,tex in ipairs(self.layerTexs) do
			tex:delete()
		end
		self.layerTexs = nil
	end

	collectgarbage()

	local mapInfo = game.getMap(mapIndex)
	if not mapInfo then
		print("map "..mapIndex.." missing")
		return
	end

	local map = mapInfo.map
	local paletteIndex = tonumber(map.palette)
	local gfxLayer3 = mapInfo.gfxLayer3
	local tilesetDatas = mapInfo.tilesetDatas
	local layerPos = mapInfo.layerPos
	local layerSizes = mapInfo.layerSizes
	local layouts = mapInfo.layouts
	local palette = mapInfo.palette
	local tilePropsData = mapInfo.tilePropsData

	print('maps[0x'..mapIndex:hex()..'] addr '
		..'0x'..(ffi.cast('uint8_t*', map) - rom):hex()
		..' = '..map[0])

	local gfxstr = mapInfo.gfxIndexes:mapi(tostring):concat'/'
	for i=1,2 do
		local tilesetData = tilesetDatas[i]
		print('map tileset'..i..' data size', tilesetData and #tilesetData)
	end

	for i=1,3 do
		print('map layer '..i..' size', layerSizes[i], 'volume', layerSizes[i]:volume())
		print('map layout'..i..' data size', layouts[i] and #layouts[i].data)
		if i > 1 then
			print('map layer'..i..' pos', layerPos[i])
		end
	end

	local palette = mapInfo.palette

	if not palette then 
		print("map "..mapIndex.." has no palette")
		return 
	end

	local palData = ffi.new'uint8_t[128*4]'
	ffi.fill(palData, ffi.sizeof(palData))
	for i=0,127 do
		for j=0,3 do
			palData[j|(i<<2)] = palette[i+1][j+1]
		end
	end
	self.palTex = GLTex2D{
		width = 16*8,
		height = 1,
		internalFormat = gl.GL_RGBA,
		format = gl.GL_RGBA,
		type = gl.GL_UNSIGNED_BYTE,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		data = palData,
	}:unbind()
assert.eq(self.palTex.data, palData)

	self.layerTexs = mapInfo
		:getLayerImages()
		:mapi(|img| do
			local tex = GLTex2D{
				width = img.width,
				height = img.height,
				internalFormat = gl.GL_R8UI,
				format = gl.GL_RED_INTEGER,
				type = gl.GL_UNSIGNED_BYTE,
				minFilter = gl.GL_NEAREST,
				magFilter = gl.GL_NEAREST,
				data = img.buffer,
			}:unbind()
			tex.image = img
			return tex
		end)
	if #self.layerTexs > 0 then
		self.mapSize:set(self.layerTexs[1].width, self.layerTexs[1].height)
	end
end

App.update = |:|do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT)

	local view = self.view
	view.mvMat
		:applyScale(self.mapSize.x / 1024, self.mapSize.y / 1024, 1)
	view.mvProjMat:mul4x4(view.projMat, view.mvMat)
	self.drawObj.uniforms.mvProjMat = view.mvProjMat.ptr

	if self.layerTexs then
		self.drawObj.texs[2] = self.palTex
		for i,tex in ipairs(self.layerTexs) do
			local k = 'drawLayer'..i
			if self[k] == nil or self[k] == true then
				
				--[[ TODO FIXME
				local blend = tex.image.blend
				if blend then
					gl.glEnable(gl.GL_BLEND)
					if (blend & 2) ~= 0 then -- sub
						--gl.glBlendEquation(gl.GL_FUNC_SUBTRACT)		-- sprite minus framebuffer
						gl.glBlendEquation(gl.GL_FUNC_REVERSE_SUBTRACT)	-- framebuffer minus sprite
					else
						gl.glBlendEquation(gl.GL_FUNC_ADD)
					end				
					local half = (blend & 1) ~= 0
					gl.glBlendColor(1, 1, 1, half and .5 or 1)
					if half then
						gl.glBlendFunc(gl.GL_CONSTANT_ALPHA, gl.GL_CONSTANT_ALPHA)
					else
						gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE)
					end
				else
				--]]do
					gl.glEnable(gl.GL_ALPHA_TEST)
					gl.glAlphaFunc(gl.GL_GREATER, .5)
				end

				self.drawObj.texs[1] = tex
				self.drawObj:draw()

				gl.glDisable(gl.GL_BLEND)
				gl.glDisable(gl.GL_ALPHA_TEST)
			end
		end
	end

	-- draw gui
	App.super.update(self)
end

App.updateGUI = |:|do
	if ig.igBeginMainMenuBar() then
		if ig.igBeginMenu'map:' then
			if ig.luatableInputInt('mapIndex', self, 'mapIndex') then
				self.mapIndex = self.mapIndex:floor():clamp(0, countof(game.maps)-1)
				self:updateMapIndex()
			end

			if self.layerTexs then
				for i=1,#self.layerTexs do
					if i > 1 then
						ig.igSameLine()
					end
					local k = 'drawLayer'..i
					if self[k] == nil then self[k] = true end
					ig.luatableTooltipCheckbox('tex '..i, self, k)
				end
			end

			ig.igEndMenu()
		end

		local label = 'viewing map #'..self.mapIndex
		if ig.igBeginMenu(label) then
			ig.igEndMenu()
		end
		ig.igEndMainMenuBar()
	end
end

return App():run()
